<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Coastal Tracker</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>

    <style>
        :root {
            --bg-color: #0d1b2a;
            --card-color: #1b263b;
            --primary-text: #e0e1dd;
            --secondary-text: #778da9;
            --accent-color: #415a77;
            --ok: #5bd38c;
            --warn: #ffcc66;
        }

        html, body {
            margin: 0;
            padding: 0 0 15vh 0; 
            width: 100%;
            min-height: 100vh;
            font-family: 'Montserrat', sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            box-sizing: border-box;
        }

        .container {
            width: 90vw;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-top: 20px;
            box-sizing: border-box;
        }

        .card {
            background-color: var(--card-color);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            flex: 1;
            transition: all 0.3s ease;
        }
        
        .card h2 {
            margin: 0 0 10px 0;
            color: var(--secondary-text);
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .data-display {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 5px 0;
        }

        .data-subtext {
            font-size: 1rem;
            font-weight: 300;
        }

        #location-data {
            font-size: 1rem;
            color: var(--secondary-text);
        }

        .tide-visualizer {
            width: 100%;
            height: 60px;
            background-color: var(--accent-color);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin-top: 15px;
        }

        /* Seamless-er wave: animate background-position on a tiling svg */
        .tide-wave {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            /* Subtle, loop-friendly wave (left/right edges align) */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" viewBox="0 0 120 20"><path fill="%23e0e1dd" fill-opacity="0.6" d="M0,10 C10,5 20,15 30,10 C40,5 50,15 60,10 C70,5 80,15 90,10 C100,5 110,15 120,10 L120,20 L0,20 Z"/></svg>');
            background-repeat: repeat-x;
            background-size: 240px 100%; /* sets a fixed tile width for smooth scrolling */
            animation: wave-scroll 8s linear infinite;
            will-change: background-position, transform;
            transition: transform 0.8s ease-out;
        }
        @keyframes wave-scroll {
            from { background-position: 0 0; }
            to   { background-position: -240px 0; }
        }

        @media (orientation: landscape) and (min-height: 400px) {
            .container {
                flex-direction: row;
                justify-content: center;
                align-items: stretch;
            }
        }
        
        .loader {
            border: 5px solid var(--accent-color);
            border-top: 5px solid var(--primary-text);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #debug-output {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 15vh;
            background-color: rgba(0,0,0,0.8);
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.75rem;
            padding: 10px 84px 10px 10px; /* space for the button */
            overflow-y: auto;
            border-top: 2px solid var(--accent-color);
            z-index: 1000;
        }
        #debug-output p {
            margin: 2px 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #copy-logs-btn {
            position: fixed;
            right: 10px;
            bottom: calc(15vh + 10px);
            z-index: 1100;
            background: var(--primary-text);
            color: #0d1b2a;
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-weight: 700;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .hint {
            font-size: 0.85rem;
            color: var(--secondary-text);
            margin-top: 8px;
            line-height: 1.4;
        }

        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.1);
            margin: 0 4px;
        }
    </style>
</head>
<body>

    <main class="container">
        <div class="card" id="location-card">
            <h2>üìç Location</h2>
            <div id="location-data">
                <div class="loader"></div>
                <p>Requesting location permission...</p>
            </div>
        </div>

        <div class="card" id="moon-card">
            <h2>üåô Moon Phase</h2>
            <div id="moon-data">
                <div class="loader"></div>
            </div>
        </div>

        <div class="card" id="tide-card">
            <h2>üåä Sea Level (MSL)</h2>
            <div id="tide-data">
                 <div class="loader"></div>
            </div>
            <p class="hint">
                This is <strong>sea level vs Mean Sea Level (MSL)</strong>, not chart datum (LAT). 
                For navigation, use official tide tables.
            </p>
        </div>
    </main>

    <!-- Copy logs button -->
    <button id="copy-logs-btn" aria-label="Copy debug logs">Copy logs</button>

    <div id="debug-output">
        <p><strong>--- DEBUG LOG ---</strong></p>
    </div>

    <script>
        const debugLog = document.getElementById('debug-output');
        function logToDebug(message) {
            console.log(message);
            const p = document.createElement('p');
            if (typeof message === 'object') {
                p.textContent = `[${new Date().toLocaleTimeString()}] ${JSON.stringify(message, null, 2)}`;
            } else {
                p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            }
            debugLog.appendChild(p);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        document.addEventListener('DOMContentLoaded', () => {
            logToDebug("Page loaded. Initializing tracker...");
            wireCopyLogs();
            getLocation();
        });

        function wireCopyLogs() {
            const btn = document.getElementById('copy-logs-btn');
            btn.addEventListener('click', async () => {
                const text = debugLog.innerText || '';
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(text);
                        logToDebug("‚úÖ Logs copied to clipboard.");
                    } else {
                        // Fallback for older browsers
                        const ta = document.createElement('textarea');
                        ta.value = text;
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                        logToDebug("‚úÖ Logs copied (fallback).");
                    }
                } catch (e) {
                    logToDebug("‚ùå Failed to copy logs: " + (e && e.message ? e.message : e));
                }
            });
        }

        function getLocation() {
            logToDebug("Attempting to get location...");
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(showPosition, showError);
            } else {
                const msg = "Geolocation is not supported by this browser.";
                logToDebug(`ERROR: ${msg}`);
                document.getElementById('location-data').innerHTML = `<p>${msg}</p>`;
            }
        }

        function showPosition(position) {
            logToDebug("Location success!");
            logToDebug(position.coords);
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            const locationEl = document.getElementById('location-data');
            locationEl.innerHTML = `<p>Lat: ${lat.toFixed(4)}, Lon: ${lon.toFixed(4)}</p>`;
            
            fetchMoonPhase(new Date());
            fetchTideData(lat, lon);
        }

        function showError(error) {
            logToDebug("Location ERROR!");
            logToDebug(error);
            const locationEl = document.getElementById('location-data');
            let message = "";
            switch(error.code) {
                case error.PERMISSION_DENIED: message = "User denied the request for Geolocation."; break;
                case error.POSITION_UNAVAILABLE: message = "Location information is unavailable."; break;
                case error.TIMEOUT: message = "The request to get user location timed out."; break;
                case error.UNKNOWN_ERROR: message = "An unknown error occurred."; break;
            }
            locationEl.innerHTML = `<p style="color: #ff8a8a;">${message}</p>`;
            document.getElementById('moon-data').innerHTML = `<p>Cannot fetch without location.</p>`;
            document.getElementById('tide-data').innerHTML = `<p>Cannot fetch without location.</p>`;
        }

        function fetchMoonPhase(date) {
            logToDebug("Fetching moon phase...");
            const moonInfo = SunCalc.getMoonIllumination(date);
            logToDebug({moonInfo});
            const phase = moonInfo.phase;
            
            let phaseName = "", phaseEmoji = "";
            if (phase < 0.03 || phase > 0.97) { phaseName = "New Moon"; phaseEmoji = "üåë"; }
            else if (phase < 0.22) { phaseName = "Waxing Crescent"; phaseEmoji = "üåí"; }
            else if (phase < 0.28) { phaseName = "First Quarter"; phaseEmoji = "üåì"; }
            else if (phase < 0.47) { phaseName = "Waxing Gibbous"; phaseEmoji = "üåî"; }
            else if (phase < 0.53) { phaseName = "Full Moon"; phaseEmoji = "üåï"; }
            else if (phase < 0.72) { phaseName = "Waning Gibbous"; phaseEmoji = "üåñ"; }
            else if (phase < 0.78) { phaseName = "Last Quarter"; phaseEmoji = "üåó"; }
            else { phaseName = "Waning Crescent"; phaseEmoji = "üåò"; }

            const illuminationPercent = (moonInfo.fraction * 100).toFixed(1);
            
            const moonEl = document.getElementById('moon-data');
            moonEl.innerHTML = `<div class="data-display">${phaseEmoji}</div><div class="data-subtext">${phaseName}</div><p>${illuminationPercent}% Illuminated</p>`;
        }

        /**
         * Fetch sea level (tide-like) data.
         * Open-Meteo Marine API variable: sea_level_height_msl (metres).
         * Note: Accuracy can be limited near complex coastlines and unreliable inland.
         */
        async function fetchTideData(lat, lon) {
            const tideEl = document.getElementById('tide-data');
            const apiUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=sea_level_height_msl&timezone=auto`;
            
            logToDebug(`Fetching tide data from URL: ${apiUrl}`);
            
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                logToDebug("Tide API Response:");
                logToDebug(data);

                if (!response.ok || data.error) {
                    throw new Error(data.reason || `API error: ${response.statusText}`);
                }

                if (data && data.hourly && data.hourly.time && data.hourly.sea_level_height_msl) {
                    const times = data.hourly.time.map(t => new Date(t));
                    const levels = data.hourly.sea_level_height_msl;
                    const unit = data.hourly_units && (data.hourly_units.sea_level_height_msl || "m");

                    const now = new Date();

                    // Find index at/just before now
                    let idx = -1;
                    for (let i = 0; i < times.length; i++) {
                        if (times[i].getTime() <= now.getTime()) idx = i; else break;
                    }
                    if (idx === -1) {
                        // Fallback: nearest by absolute difference
                        let minDiff = Infinity;
                        for (let i = 0; i < times.length; i++) {
                            const d = Math.abs(times[i].getTime() - now.getTime());
                            if (d < minDiff) { minDiff = d; idx = i; }
                        }
                    }
                    if (idx === -1) throw new Error("Could not match current time to hourly sea level.");

                    const currentLevel = levels[idx];

                    // Simple hi/lo estimator: find local max/min within +/- 6 hours
                    function findLocalExtreme(center, window = 6) {
                        const start = Math.max(1, center - window);
                        const end = Math.min(levels.length - 2, center + window);
                        let hi = {i: center, v: levels[center]};
                        let lo = {i: center, v: levels[center]};
                        for (let i = start; i <= end; i++) {
                            // local max
                            if (levels[i] >= levels[i-1] && levels[i] >= levels[i+1] && levels[i] > hi.v) {
                                hi = {i, v: levels[i]};
                            }
                            // local min
                            if (levels[i] <= levels[i-1] && levels[i] <= levels[i+1] && levels[i] < lo.v) {
                                lo = {i, v: levels[i]};
                            }
                        }
                        return {hi, lo};
                    }
                    const {hi, lo} = findLocalExtreme(idx, 6);

                    // Map sea level (m) to visualization height.
                    // Clamp from -1.5m..+1.5m -> 0%..100% (illustrative only)
                    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
                    const pct = ((clamp(currentLevel, -1.5, 1.5) + 1.5) / 3.0) * 100;
                    const translateY = 100 - pct; // water rises with higher level

                    const trend = (levels[idx] - (levels[idx-1] ?? levels[idx])) || 0;
                    const trendText = trend > 0 ? "Rising" : trend < 0 ? "Falling" : "Steady";

                    tideEl.innerHTML = `
                        <div class="data-display">${Number(currentLevel).toFixed(2)}${unit}</div>
                        <div class="data-subtext">Sea Level vs MSL ‚Äî <span class="pill">${trendText}</span></div>
                        <div class="tide-visualizer" title="Illustrative wave height mapped from sea level vs MSL">
                            <div class="tide-wave" style="transform: translateY(${translateY}%);"></div>
                        </div>
                        <p class="hint">
                            Timestamp: ${times[idx].toLocaleString()} ‚Ä¢ Timezone: ${data.timezone_abbreviation}
                        </p>
                        <p class="hint">
                            Est. next/prev extremes (heuristic):
                            ${hi.i !== idx ? `High ‚âà ${times[hi.i].toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} (${hi.v.toFixed(2)}${unit})` : ''}
                            ${hi.i !== idx && lo.i !== idx ? ' ‚Ä¢ ' : ''}
                            ${lo.i !== idx ? `Low ‚âà ${times[lo.i].toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} (${lo.v.toFixed(2)}${unit})` : ''}
                        </p>
                    `;
                } else {
                    throw new Error("Hourly sea level data not available in the API response.");
                }

            } catch (error) {
                logToDebug(`Tide fetch ERROR: ${error.message}`);
                console.error("Failed to fetch tide data:", error);
                tideEl.innerHTML = `<p style="color: #ff8a8a;">Could not fetch sea level.</p><p class="hint">${error.message}</p>`;
            }
        }
    </script>

</body>
</html>
